<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <title>Pi Runner - Mini Game</title>
    <link rel="stylesheet" href="css/game.css" />
  </head>
  <body>
    <div class="game-container">
      <div class="header">
        <h1>ü•ß Pi Runner</h1>
        <div class="score-display">
          <div>Score: <span id="currentScore">0</span></div>
          <div id="player-info" style="font-size: 12px; margin-top: 5px"></div>
        </div>
      </div>
      <canvas id="gameCanvas" width="760" height="200"></canvas>
      <div class="controls">
        Press SPACE or click to jump! üöÄ
        <span id="login-hint" style="margin-left: 20px"></span>
      </div>
    </div>

    <div class="game-over-screen" id="gameOverScreen">
      <div class="game-over-content">
        <h2>Game Over!</h2>
        <div class="final-score" id="finalScore">0</div>

        <div class="scoreboard" id="scoreboard">
          <h3>üèÜ Top 5 Scores</h3>
          <ul class="score-list" id="scoreList"></ul>
        </div>

        <div class="buttons">
          <button class="btn btn-primary" onclick="restartGame()">
            Play Again
          </button>
          <a href="/cockpit" class="btn btn-secondary">Cockpit</a>
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      let gameRunning = false;
      let score = 0;
      let gameSpeed = 6;
      let gravity = 0.6;
      let difficultyMultiplier = 1;
      let currentUser = null;

      // Check login status
      async function checkLoginStatus() {
        try {
          const response = await fetch("/api/whoami");
          const data = await response.json();
          currentUser = data;

          const playerInfo = document.getElementById("player-info");
          const loginHint = document.getElementById("login-hint");

          if (data.loggedIn) {
            playerInfo.textContent = `Spieler: ${data.userId}`;
            loginHint.innerHTML = "";
          } else {
            playerInfo.textContent = "Spieler: Anonymous";
            loginHint.innerHTML =
              '<a href="/" style="color: #667eea;">Login</a> f√ºr Namensanzeige';
          }
        } catch (error) {
          console.error("Error checking login status:", error);
        }
      }

      // Player (Raspberry Pi)
      const player = {
        x: 50,
        y: 150,
        width: 40,
        height: 40,
        dy: 0,
        jumpPower: -12,
        grounded: false,
        emoji: "ü•ß",
      };

      // Obstacles
      let obstacles = [];
      let obstacleTimer = 0;
      let obstacleInterval = 90;
      let minObstacleInterval = 40;
      let maxObstacleInterval = 100;

      // Background elements
      let clouds = [];
      let groundOffset = 0;

      // Initialize clouds
      for (let i = 0; i < 3; i++) {
        clouds.push({
          x: Math.random() * canvas.width,
          y: Math.random() * 50,
          speed: 0.5 + Math.random() * 0.5,
        });
      }

      function jump() {
        if (player.grounded && gameRunning) {
          player.dy = player.jumpPower;
          player.grounded = false;
        }
      }

      function startGame() {
        gameRunning = true;
        score = 0;
        gameSpeed = 6;
        difficultyMultiplier = 1;
        obstacles = [];
        obstacleTimer = 0;
        obstacleInterval = 90;
        minObstacleInterval = 40;
        maxObstacleInterval = 100;
        player.y = 150;
        player.dy = 0;
        player.grounded = false;
        document.getElementById("currentScore").textContent = "0";
        gameLoop();
      }

      function restartGame() {
        document.getElementById("gameOverScreen").style.display = "none";
        startGame();
      }

      async function endGame() {
        gameRunning = false;
        document.getElementById("finalScore").textContent = score;

        // Save score
        try {
          await fetch("/api/scores", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ score }),
          });

          // Load scoreboard
          const response = await fetch("/api/scores");
          const scores = await response.json();
          displayScoreboard(scores);
        } catch (error) {
          console.error("Error saving score:", error);
        }

        document.getElementById("gameOverScreen").style.display = "flex";
      }

      function displayScoreboard(scores) {
        const scoreList = document.getElementById("scoreList");
        scoreList.innerHTML = "";

        scores.slice(0, 5).forEach((s, index) => {
          const li = document.createElement("li");
          li.className = "score-item";
          li.innerHTML = `
            <span class="score-rank">#${index + 1}</span>
            <span class="score-value">${s.score}</span>
            <span>${new Date(s.timestamp).toLocaleDateString("de-DE")}</span>
          `;
          scoreList.appendChild(li);
        });
      }

      function updatePlayer() {
        // Apply gravity
        player.dy += gravity;
        player.y += player.dy;

        // Ground collision
        const groundY = canvas.height - player.height - 10;
        if (player.y >= groundY) {
          player.y = groundY;
          player.dy = 0;
          player.grounded = true;
        }
      }

      function updateObstacles() {
        obstacleTimer++;

        if (obstacleTimer > obstacleInterval) {
          // Random obstacle types with varying sizes
          const obstacleTypes = [
            { emoji: "üåµ", width: 20, height: 45 },
            { emoji: "ü™®", width: 25, height: 35 },
            { emoji: "üå≥", width: 30, height: 50 },
            { emoji: "üî•", width: 20, height: 40 },
            { emoji: "üå¥", width: 25, height: 48 },
            { emoji: "‚ö°", width: 18, height: 38 },
          ];

          const type =
            obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];

          obstacles.push({
            x: canvas.width,
            y: canvas.height - 50,
            width: type.width,
            height: type.height,
            emoji: type.emoji,
          });
          obstacleTimer = 0;

          // More aggressive spacing reduction
          obstacleInterval =
            minObstacleInterval +
            Math.random() * (maxObstacleInterval - minObstacleInterval);
        }

        // Move and remove obstacles
        obstacles = obstacles.filter((obstacle) => {
          obstacle.x -= gameSpeed;
          return obstacle.x + obstacle.width > 0;
        });
      }

      function checkCollision() {
        for (let obstacle of obstacles) {
          if (
            player.x < obstacle.x + obstacle.width &&
            player.x + player.width > obstacle.x &&
            player.y < obstacle.y + obstacle.height &&
            player.y + player.height > obstacle.y
          ) {
            endGame();
            return true;
          }
        }
        return false;
      }

      function updateScore() {
        score++;
        document.getElementById("currentScore").textContent = score;

        // More aggressive difficulty increase
        if (score % 200 === 0) {
          gameSpeed += 0.8;
          difficultyMultiplier += 0.1;

          // Reduce obstacle spacing over time
          maxObstacleInterval = Math.max(60, maxObstacleInterval - 5);
          minObstacleInterval = Math.max(30, minObstacleInterval - 2);
        }
      }

      function drawBackground() {
        // Sky
        ctx.fillStyle = "#87CEEB";
        ctx.fillRect(0, 0, canvas.width, canvas.height - 50);

        // Clouds
        ctx.font = "20px Arial";
        clouds.forEach((cloud) => {
          ctx.fillText("‚òÅÔ∏è", cloud.x, cloud.y + 20);
          cloud.x -= cloud.speed;
          if (cloud.x < -30) {
            cloud.x = canvas.width;
            cloud.y = Math.random() * 50;
          }
        });

        // Ground
        ctx.fillStyle = "#8B7355";
        ctx.fillRect(0, canvas.height - 50, canvas.width, 50);

        // Ground pattern
        ctx.fillStyle = "#6B5345";
        groundOffset -= gameSpeed;
        if (groundOffset < -20) groundOffset = 0;
        for (let i = groundOffset; i < canvas.width; i += 20) {
          ctx.fillRect(i, canvas.height - 45, 15, 5);
        }
      }

      function drawPlayer() {
        ctx.font = "40px Arial";
        ctx.fillText(player.emoji, player.x, player.y + player.height);
      }

      function drawObstacles() {
        ctx.font = "40px Arial";
        obstacles.forEach((obstacle) => {
          ctx.fillText(
            obstacle.emoji,
            obstacle.x,
            obstacle.y + obstacle.height
          );
        });
      }

      function gameLoop() {
        if (!gameRunning) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        drawBackground();
        updatePlayer();
        updateObstacles();
        drawPlayer();
        drawObstacles();

        if (!checkCollision()) {
          updateScore();
        }

        requestAnimationFrame(gameLoop);
      }

      // Event listeners
      document.addEventListener("keydown", (e) => {
        if (e.code === "Space") {
          e.preventDefault();
          if (!gameRunning) {
            startGame();
          } else {
            jump();
          }
        }
      });

      canvas.addEventListener("click", () => {
        if (!gameRunning) {
          startGame();
        } else {
          jump();
        }
      });

      // Check login status on page load
      checkLoginStatus();

      // Draw initial state
      drawBackground();
      drawPlayer();
      ctx.fillStyle = "#333";
      ctx.font = "24px Arial";
      ctx.textAlign = "center";
      ctx.fillText("Click or press SPACE to start!", canvas.width / 2, 100);
    </script>
  </body>
</html>
